# Opérations arithmétiques et logiques pour le codage de l'ALU.
# Tous les entiers binaires sont encodés avec les bits de poids le plus fort à droite.
# On a donc a[0..n-1] = somme des a[i]*(2^i), pour i de 0 à (n-1)

##################################
# Opérations standard sur n bits #
##################################

# (Avec des noms bien francisés parce que je peux pas réutiliser les mots-clés déjà
# définis. Et puis je trouve que "Nou", ça sonne bien :D)

# Opérations logiques => checked

Et <1> (a,b)
   And A (a,b)
   -> o : A.o ;

Et <n> (a[n],b[n])
   Et<n-1> D (a[0..n-2],b[0..n-2])
   And F (a[n-1],b[n-1])
   -> o[n] : { D.o,F.o } ;

Ou <1> (a,b)
   Or A (a,b)
   -> o : A.o ;

Ou <n> (a[n],b[n])
   Ou<n-1> D (a[0..n-2],b[0..n-2])
   Or F (a[n-1],b[n-1])
   -> o[n] : { D.o,F.o } ;

Xou <1> (a,b)
   Xor A (a,b)
   -> o : A.o ;

Xou <n> (a[n],b[n])
   Xou<n-1> D (a[0..n-2],b[0..n-2])
   Xor F (a[n-1],b[n-1])
   -> o[n] : { D.o,F.o } ;

Neg <1> (a)
    Not M(a)
    -> o : M.o ;

Neg <n> (a[n])
    Neg<n-1> M (a[0..n-2])
    Not F (a[n-1])
    -> o[n] : { M.o, F.o } ;

Nou <n> (a[n],b[n])
    Ou <n> O(a[0..n-1],b[0..n-1])
    Neg <n> N(O.o)
    -> o[n] : N.o ;

Net <n> (a[n],b[n])
    Et <n> O(a[0..n-1],b[0..n-1])
    Neg <n> N(O.o)
    -> o[n] : N.o ;

Multiplexer <1> (selector, input0[1], input1[1])
	Mux M(selector, input0, input1)
	-> o : M.o;

Multiplexer <n> (selector, input0[n], input1[n])
	Multiplexer<n-1> Low(selector, input0[0..n-2], input1[0..n-2])
	Mux High(selector, input0[n-1], input1[n-1])
	-> o[n] : {Low.o, High.o};


# Constantes utiles pour la suite => checked

Zero<1> ()
    Gnd G()
    -> o[1] : G.o;

Zero<n> ()
    Gnd H()
    Zero<n-1> L()
    -> o[n] : {L.o, H.o};

Un <1> ()
    Vdd V()
    -> o : V.o ;

Un <n> ()
    Un <n-1> U()
    Gnd G()
    -> o[n] : { U.o , G.o };

MoinsUn<1> ()
    Vdd V()
    -> o[1] : V.o;

MoinsUn <n> ()
    Vdd H()
    MoinsUn <n-1> L
    -> o[n] : {L.o, H.o};


# Addition => checked

HalfAdder ( a, b)
    Xor X( a, b)
    And	A( a, b)
    -> o : X.o, c : A.o ;

FullAdder ( a, b, c)
    HalfAdder H1( a, b)
    HalfAdder H2( c, H1.o)
    Or O( H1.c, H2.c)
    -> o : H2.o, c : O.o ;  

Adder <1> (a, b)
    HalfAdder F (a, b) 
    -> o : F.o, c : F.c ;

Adder <n> (a[n] , b[n])
    Adder<n-1> A (a[0..n-2], b[0..n-2])  
    FullAdder F (a[n-1], b[n-1], A.c) 
    -> 
       o[n] : { A.o, F.o } , 
       c : F.c ;


# Négation (arithmétique) unaire => checked

UnarySub <n> (a[n])
    Neg <n> NonA(a[0..n-1])
    Un <n> U()
    Adder <n> MoinsA(NonA.o,U.o)
    -> o[n] : MoinsA.o ;


# Soustraction => checked

Sub <n> (a[n],b[n])
    UnarySub <n> MoinsB(b[0..n-1])
    Adder <n> AMoinsB(MoinsB.o,a[0..n-1])
    -> o[n] : AMoinsB.o ,
       c : AMoinsB.c ;


# Transforme un entier n bits en un entier n+m bits => checked

Agrandir <n,1> (a[n])
    -> o[n+1] : {a[0..n-1],a[n-1]} ;
    
Agrandir <n,m> (a[n])
    Agrandir <n,m-1> A(a[0..n-1])
    -> o[n+m] : { A.o, a[n-1] } ;


# Décale un entier n bits de m bits vers la droite =>checked

RShift <n,m> (a[n])
   Zero <m> Z()
   -> o[m+n] : { Z.o , a[0..n-1] } ;

# Même chose, mais ne renvoie que les n premiers bits => checked
# /!\ On doit avoir n>m /!\

RShiftT <n,m> (a[n])
   Zero <m> Z()
   -> o[n] : { Z.o , a[0..n-m-1] } ;

# Décale un entier n bits de m bits vers la gauche => checked
# /!\ On doit avoir n>m /!\

LShift <n,m> (a[n])
    -> o[n-m] : a[m..n-1] ;

# Même chose, mais on obtient un entier n bits en complétant avec des zéros => checked

LShiftT <n,m> (a[n])
    Zero <m> Z()
    -> o[n] : { a[m..n-1] , Z.o } ;


# Multiplication => pas checked 

Mult <n,1> (a[n],b)
    Zero <n> Z()
    Multiplexer <n> M(b,Z.o,a[0..n-1])
    -> o[n] : M.o ;

Mult <n,m> (a[n],b[m])
    Mult <n,m-1> EtapePrecedente(a[0..n-1],b[0..m-2])
    Agrandir <n+m-2,1> TermePrecedent(EtapePrecedente.o)
    RShift <n,m-1> Decalage(a[0..n-1])
    Zero <n+m-1> Z()
    Multiplexer <n+m-1> TermeActuel(b[m-1],Z.o,Decalage.o)
    Adder <n+m-1> Renvoi(TermePrecedent.o,TermeActuel.o)
    -> o[n+m-1] : Renvoi.o ;


# Operations de comparaison (Renvoie 1 pour true, 0 pour false) => checked

Egal <1> (a,b)
    Xor X(a,b)
    Not R(X.o)
    -> o : R.o ;

Egal <n> (a[n],b[n])
    Egal <n-1> P(a[0..n-2],b[0..n-2])
    Egal <1> S(a[n-1],b[n-1])
    And R(P.o,S.o)
    -> o : R.o ;

SupStrict <1> (a,b)
    Not NonB(b)
    And R(a,NonB.o)
    -> o : R.o ;

SupStrict <n> (a[n],b[n])
    SupStrict <n-1> PSS(a[0..n-2],b[0..n-2])
    SupStrict <1> SSS(a[n-1],b[n-1])
    Egal <1> SE(a[n-1],b[n-1])
    And OK(PSS.o,SE.o)
    Or R(SSS.o,OK.o)
    -> o : R.o ;

InfStrict <1> (a,b)
    Not NonA(a)
    And R(b,NonA.o)
    -> o : R.o ;

InfStrict <n> (a[n],b[n])
    InfStrict <n-1> PIS(a[0..n-2],b[0..n-2])
    InfStrict <1> SIS(a[n-1],b[n-1])
    Egal <1> SE(a[n-1],b[n-1])
    And OK(PIS.o,SE.o)
    Or R(SIS.o,OK.o)
    -> o : R.o ;

SupEgal <n> (a[n],b[n])
    Egal <n> E(a[0..n-1],b[0..n-1])
    SupStrict <n> SS(a[0..n-1],b[0..n-1])
    Or R(E.o,SS.o)
    -> o : R.o ;

InfEgal <n> (a[n],b[n])
    Egal <n> E(a[0..n-1],b[0..n-1])
    InfStrict <n> SS(a[0..n-1],b[0..n-1])
    Or R(E.o,SS.o)
    -> o : R.o ;

#######################
# Opérations Filtrées #
#######################

#Filtre <m> : renvoie m sorties 1 si les deux arguments sont égaux, 32 sorties 0 sinon => checked

Filtre <1> (a[4], b[4])
   Egal<4> Eg(a[0..3], b[0..3])
   -> o : Eg.o;   

Filtre <m> (a[4], b[4])
   Filtre <m-1> F1 (a[0..3], b[0..3])
   Filtre <1> F2 (a[0..3], b[0..3]) 
   -> o[m] : { F1.o, F2.o };


# Toutes les opérations renvoient leur resultats sur m bits si le selecteur correspond à leur code, que des 0 sinon

# Logique - Unaire => checked , a utiliser

Not32 (a[32])
    Neg <32> A(a[0..31])
    -> o[32] : A.o ;

# Logique - Binaire

#Et => checked
BinOp<0,m> (a[m], b[m], sel[4]) 
    Et <m> A(a[0..m-1], b[0..m-1])
    Filtre<m> F($0000, sel[0..3])
    Et <m> Res (A.o, F.o)             
    -> o[m] : Res.o;

#Ou => checked
BinOp<1,m> (a[m], b[m], sel[4])
    Ou <m> A(a[0..m-1], b[0..m-1])
    Filtre<m> F($1000, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;

#Xor => checked
BinOp<2,m> (a[m], b[m], sel[4])
    Xou <m> A(a[0..m-1], b[0..m-1])
    Filtre<m> F($0100, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;

#Nand => checked
BinOp<3,m> (a[m], b[m], sel[4])
    Net <m> A(a[0..m-1],b[0..m-1])
    Filtre<m> F($1100, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;

#Nor => checked
BinOp<4,m> (a[m], b[m], sel[4])
    Nou <m> A(a[0..m-1],b[0..m-1])
    Filtre<m> F($0010, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;


# Logique - Ternaire

Mux32 (s,a[32],b[32])
    Multiplexer <32> M(s,a[0..31],b[0..31])
    -> o[32] : M.o ;

# Arithmétique - Unaire

USub32 (a[32])
    UnarySub <32> A(a[0..31])
    -> o[32] : A.o ;

# Arithmétique - Binaire

#addition
BinOp<5,m> (a[m], b[m], sel[4])
    Adder <m> A(a[0..m-1],b[0..m-1])
    Filtre<m> F($1010, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;

#Soustraction
BinOp<6,m> (a[m],b[m], sel[4])
    Sub <m> A(a[0..m-1],b[0..m-1])
    Filtre<m> F($0110, sel[0..3])
    Et <m> Res (A.o, F.o)          
    -> o[m] : Res.o ;

#Multiplication

BinOp<7,m> (a[m],b[m],sel[4])
    Mult <m,m> M(a[0..m-1],b[0..m-1])
    Filtre<m> F($1110, sel[0..3])
    Et <m> Res (M.o[0..m-1],F.o)
    -> o[m] : Res.o[0..m-1] ;

# Comparaison - Binaire
# Renvoie 0 (pour false) ou 1 (pour true)

#Egal
BinOp<8,m> (a[m],b[m], sel[4])
    Egal <m> A(a[0..m-1],b[0..m-1])
    Filtre<1> F($0001, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()     #Attention a binOp<8,1>     
    -> o[m] : {Res.o, Z.o} ;

#Différent
BinOp<9,m> (a[m],b[m], sel[4])
    Egal <m> B(a[0..m-1],b[0..m-1])
    Not A(B.o)
    Filtre<1> F($1001, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()          
    -> o[m] : {Res.o, Z.o} ;

#inf
BinOp<10,m> (a[m],b[m], sel[4])
    InfStrict <m> A(a[0..m-1],b[0..m-1])
    Filtre<1> F($0101, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()          
    -> o[m] : {Res.o, Z.o} ;

#sup
BinOp<11,m> (a[m],b[m], sel[4])
    SupStrict <m> A(a[0..m-1],b[0..m-1])
    Filtre<1> F($1101, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()          
    -> o[m] : {Res.o, Z.o} ;

#inf ou egal
BinOp<12,m> (a[m],b[m], sel[4])
    InfEgal <m> A(a[0..m-1],b[0..m-1])
    Filtre<1> F($0011, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()          
    -> o[m] : {Res.o, Z.o} ;

#sup ou egal
BinOp<13,m> (a[m],b[m], sel[4])
    SupEgal <m> A(a[0..m-1],b[0..m-1])
    Filtre<1> F($1011, sel[0..3])
    Et <1> Res (A.o, F.o)
    Zero<m-1> Z()          
    -> o[m] : {Res.o, Z.o} ;

#####################
# Entier sur m bits #
#####################

Entier <2*n,1> ()
   -> o : $0;

Entier <n,1> ()
   -> o : $1;

Entier <2*n,m> ()
   Entier <n, m-1> E()
   -> o[m] : {$0 ,E.o}; 

Entier <2*n+1,m> ()
   Entier <n, m-1> E()
   -> o[m] : {$1 ,E.o}; 

#######
# ALU #
#######

AluPartiel <0,m> (a[m], b[m], sel[4])
   BinOp<0,m> B(a[0..m-1], b[0..m-1], sel[0..3])
   -> o[m] : B.o;
   
AluPartiel <n,m> (a[m], b[m], sel[4])
   AluPartiel <n-1,m> A(a[0..m-1], b[0..m-1], sel[0..3])
   BinOp <n,m> B(a[0..m-1], b[0..m-1], sel[0..3])
   Ou <m> O(A.o, B.o)
   -> o[m] : O.o;   

Alu <m> (a[m], b[m], sel[4])
   AluPartiel <13,m> A(a[0..m-1], b[0..m-1], sel[0..3])
   -> o[m] : A.o;  

####################
# Testeur de l'ALU #
####################

#Le testeur prend en argument : le premier entier, l'id de l'operation, le deuxième entier puis le nombre de bits

Testeur <a ,iOp, b, m> ()
   Entier <a,m> A()
   Entier <b,m> B()
   Entier <iOp,4> Sel()
   Alu <m> Res(A.o, B.o, Sel.o) 
   -> o[m] : Res.o;

#Pour multiplier 42 et 17 sur 32 bits :
#start Testeur<42,7,17, 32>

#####################
# Registres simples # 
#####################

#On commence par construire un miniRegistre, modeEcriture est un booléen indiquant s'il
#faur donner au registre une nouvelle valeur (val), sinon le registre garde son ancienne valeur.

MiniRegistre (modeEcriture, val) 
   Reg R(NouvVal.o)
   Not PasModeEcriture(modeEcriture)
   And A1(modeEcriture,val)
   And A2(PasModeEcriture.o,R.o)
   Or NouvVal(A1.o,A2.o)
   -> o : R.o;

Registre <1> (modeEcriture, val)
   MiniRegistre M(modeEcriture, val)
   -> o : M.o;

Registre <n> (modeEcriture, val[n])
   Registre <n-1> Bas(modeEcriture, val[0..n-2])
   MiniRegistre Haut(modeEcriture, val[n-1])
   -> o[n] : {Bas.o, Haut.o};   

#####################
# Registres filtrés #
#####################

#Filtre pour le modèle d'adressage sur 5 bits :

FiltreAdd <1> (a[5], b[5])
   Egal<5> Eg(a[0..4], b[0..4])
   -> o : Eg.o;   

FiltreAdd <m> (a[5], b[5])
   FiltreAdd <m-1> F1 (a[0..4], b[0..4])
   FiltreAdd <1> F2 (a[0..4], b[0..4]) 
   -> o[m] : { F1.o, F2.o };

#On définit alors les registres à action filtrée selon un selecteur:

Regi<id,m> ( modeEcriture, sel[5], val[m])
   Entier <id,5> Code()    
   FiltreAdd <m> F(sel[0..4], Code.o[0..4])  
   And ModeEcriture (modeEcriture, F.o[0])        
   Registre <m> R(ModeEcriture.o, val[0..m-1])
   Et <m> Res(F.o[0..m-1], R.o[0..m-1]) 
   -> o[m] : Res.o;
   
#############################
# Gestionnaire de registres #
#############################
  
Gestionnaire <0,m> (modeEcriture, sel[5], val[m])
   Regi<0,m> R(modeEcriture, sel[0..4], val[0..m-1]) 
   -> o[m] : R.o;

Gestionnaire <n,m> (modeEcriture, sel[5], val[m])
   Gestionnaire <n-1,m> G(modeEcriture, sel[0..4], val[0..m-1]) 
   Regi <n-1,m> R(modeEcriture, sel[0..4], val[0..m-1])
   Ou <m> O(G.o, R.o)
   -> o[m] : O.o;

#############################################
# Simulateur pour entrée à plusieurs cycles #
#############################################

#le bloc suivant renvoie son argument puis (aux cycles suivants) ne 
#donne plus que des zeros.

BitPuisZeros (bit)
   Vdd V()
   Reg R(V.o)
   Not F(R.o)
   And Res(F.o, bit)
   -> o : Res.o;

Entree<1,1> (a)
   BitPuisZeros Res(a)
   -> o : Res.o;

Entree<1,m> (a[m])
   Entree<1,m-1> Deb(a[0..m-2])
   Entree<1,1> Fin(a[m-1])
   -> o[m] : {Deb.o, Fin.o};
 
Delai <1> (a)
   Reg R(a)
   -> o : R.o;

Delai <m> (a[m])
   Delai <m-1> Deb(a[0..m-2])
   Reg Fin(a[m-1])
   -> o[m] : {Deb.o, Fin.o};

# Dans le bloc suivant n est le nombre de cycles, m le nombre d'entrées

Entree <n,m> (a[n*m])
   Entree<n-1,m> Fin(a[m..(n*m)-1])
   Entree<1,m> Deb(a[0..m-1])
   Delai<m> D(Fin.o)
   Ou<m> Res (D.o, Deb.o)
   -> o[m] : Res.o;

#Pour faire 4 cycles avec 3 entrée
#start Entree <4,3>

#####################################
# Testeur gestionnaire de registres #
#####################################

#On se donne 32 registres

TesteurReg <nbBits, nbCycles> ( a[nbCycles*(1 + 5 + nbBits)] )
   Entree<nbCycles,1+5+nbBits> E(a[0..nbCycles*(1 + 5 + nbBits)-1])
   Gestionnaire<32,nbBits> G(E.o[0], E.o[1..5], E.o[6..(5+nbBits)])
   ->o[nbBits] : G.o;

#start TesteurReg <4,5>

################
# Instructions #
################

# On fait d'abord un selecteur qui prend en entrée une adresse sur n bits 
# et renvoie 2^n sorties dont seule celle à la bonne adresse vaut 1.

Selecteur <1> (a)
   Not NonA(a)
   -> o[2] : {NonA.o, a};

FiltreSel <1> (a, b)
   And Res(a,b)
   -> o : Res.o;

FiltreSel <n> (a[n], b)
   FiltreSel <n-1> Haut(a[0..n-2], b)
   FiltreSel <1> Bas(a[n-1], b)
   -> o[n] : {Haut.o, Bas.o};

Selecteur <n> (a[n])
   Selecteur <n-1> Bas(a[0..n-2])
   Selecteur <n-1> Haut(a[0..n-2])
   Not NonA(a[n-1])
   FiltreSel <2^(n-1)> ResBas(Bas.o, NonA.o)
   FiltreSel <2^(n-1)> ResHaut(Haut.o, a[n-1])
   -> o[2^n] : {ResBas.o, ResHaut.o}; 


# Un bloc de n instructions filtrées sur m bits.

BlocInstr<1,m> (a[m], filtre)
   FiltreSel <m> Res(a[0..m-1], filtre)
   -> o[m] : Res.o;

BlocInstr<n,m> (a[n*m], filtre[n])
   BlocInstr<n-1,m> Haut(a[0..m*(n-1)-1], filtre[0..n-2])
   BlocInstr<1,m> Bas(a[m*(n-1)..m*n-1], filtre[n-1])
   Ou <m> Res(Haut.o, Bas.o)
   -> o[m] : Res.o;    

# On branche alors le selecteur sur le bloc d'instructions. 
# Executeur <n,m,b> a n instructions sur m bits et b désigne le nombre de bit d'adressage 
# Il prend en entrée le programme et l'adresse de l'instruction a effectuer et renvoie les 
# m bits correspondant a cette instruction
# /!\ On doit bien sur avoir 2^b >= n.

Executeur <n,m,b> (a[n*m], adresse[b])
   Selecteur <b> Filtre(adresse[0..b-1])
   BlocInstr <n,m> B(a[0..n*m-1], Filtre.o[0..n-1]) 
   -> o[m] : B.o;

#start Executeur<4,3,2>

##############
# Mini Micro #
##############


#### Decodage 

#On définit Cycleur<a,b,c> dont la sortie vaut successsivement : a,b,c,a,b,c,a,b,c

RegAvecValIni <0> (in)
   Reg R(in)
   -> o : R.o;

RegAvecValIni <1> (in)
   Not N1(in)
   Reg R(N1.o)
   Not N2(R.o)
   -> o : N2.o;

Cycleur <a,b,c> ()
   RegAvecValIni <c> R1(R3.o)
   RegAvecValIni <b> R2(R1.o)
   RegAvecValIni <a> R3(R2.o)
   -> o : R3.o;

#start Cycleur<0,1,1>

# R format
  
DecodeurR (opcode[6], rs[5], rt[5], rd[5], shift[5], funct[6], alu[32], gestReg[32]) #rd est l'adresse du resultat
   Cycleur<1,0,0> CRS ()
   Cycleur<0,1,0> CRT ()
   Cycleur<0,0,1> CRD ()
   Cycleur<0,0,1> CycleLectEcr()
   FiltreSel <5> FRS(rs[0..4], CRS.o)  
   FiltreSel <5> FRT(rt[0..4], CRT.o)  
   FiltreSel <5> FRD(rd[0..4], CRD.o)   
   Ou <5> O(FRS.o, FRT.o)  
   Ou <5> SortieAdresseReg(O.o, FRD.o)
 
   Cycleur<0,0,1> FALU()
   Delai <32> ValRS(gestReg[0..31])  
   FiltreSel <32> ValOp1(ValRS.o, FALU.o) 
   FiltreSel <32> ValOp2(gestReg[0..31], FALU.o)

   -> versGestReg[38] : {CycleLectEcr.o, SortieAdresseReg.o, alu[0..31]},
      versAlu[68] : {ValOp1.o, ValOp2.o, $1010};  #On ne met que l'addition pour l'instant

# I format

DecodeurI (opcode[6], rs[5], rt[5], imm[16], alu[32], gestReg[32]) #rt est l'adresse de resultat
   Cycleur<1,0,0> CRS ()
   Cycleur<0,0,1> CRT ()
   Cycleur<0,0,1> CycleLectEcr()
   FiltreSel <5> FRS(rs[0..4], CRS.o)  
   FiltreSel <5> FRT(rt[0..4], CRT.o)   
   Ou <5> SortieAdresseReg(FRS.o, FRT.o)
 
   Cycleur<0,0,1> FALU()
   Delai <32> ValRS(gestReg[0..31])  
   FiltreSel <32> ValOp1(ValRS.o, FALU.o) 
   FiltreSel <32> ValOp2({imm[0..15], $0000000000000000}, FALU.o)

   -> versGestRegModeEcr :  CycleLectEcr.o,
      versGestRegAd[5] : SortieAdresseReg.o, 
      versGestRegVal[32] :  alu[0..31],
      versAluOp1[32] : ValOp1.o, 
      versAluOp2[32] : ValOp2.o,
      versAluTypeOp[4] : $1010;  #On ne met que l'addition pour l'instant        

#Mini-Micro

ProgCounter <b> ()  #Version très primitive
   Zero <b> Z
   -> o[b] : Z.o;

#n designe le nombre d'instructions, b le nombre de bits d'adressage d'une instruction

MiniMicro <n,b> (prog[n*32])
   ProgCounter <b> PC()
   Executeur <n,32,b> I(prog[0..n*32-1], PC.o)
   FiltreSel<32> F(D.versAluOp1[0..31], $1)
   Alu <32> ALU(F.o[0..31], D.versAluOp2[0..31], D.versAluTypeOp[0..3])
   Gestionnaire <32,32> GR(D.versGestRegModeEcr, D.versGestRegAd[0..4], D.versGestRegVal[0..31])
   DecodeurI D(I.o[0..5], I.o[6..10], I.o[11..15], I.o[16..31], ALU.o, GR.o)
   -> o[32] : ALU.o;

start MiniMicro<1,1>








