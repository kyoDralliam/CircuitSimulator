\documentclass{beamer}

\usepackage[T1]{fontenc} 
\usepackage[latin1]{inputenc}
\usepackage[frenchb]{babel}

\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{listings}

\usepackage{beamerthemesplit} 

\title{Horloge et calendrier}
\author{Damien Desfontaines}
\date{\today}

\begin{document}

\section{Principe}

\subsection{Objectifs et contraintes}

\frame
{
  \frametitle{Objectifs et contraintes}
  Objectif : Écrire en assembleur MIPS un programme prenant un timestamp en
  entrée et renvoyant la date et l'heure.
  
  \vspace{0.5cm}

  Quelques contraintes supplémentaires :
  \begin{itemize}
    \item Pas d'instructions \texttt{mul} ni \texttt{div}
    \item Pas de décalage à droite (= multiplication par $2^n$)
    \item Renvoi de la date et heure sous le format ``afficheur 7 segments''
  \end{itemize}
}

\subsection{Plan d'attaque}

\frame
{
  \frametitle{Plan d'attaque}
  Il faut donc :
  \begin{itemize}
    \item Recoder la multiplication à partir de l'addition
    \item Recoder la division à partir de la multiplication
    \item Écrire l'algorithme de transformation d'un timestamp en format
    date/heure classique
    \item Trouver un moyen efficace de convertir un entier décimal en format
    ``afficheur 7 segments''
  \end{itemize}
}

\section{Mise en oeuvre}

\subsection{Multiplication, division}

\frame
{
  \frametitle{Principe de la multiplication}
  Supposons que l'on veuille multiplier \$a0 et \$a1. L'algorithme est le
  suivant :
  \begin{enumerate}
    \item Si \texttt{\$a1} = 0, on renvoie 0
    \item Si \texttt{\$a1} = 1, on renvoie \texttt{\$a0}
    \item Sinon, soit $x=0$ si \texttt{\$a1} est pair, et $x=\texttt{\$a1}$ sinon
    \item On fait $\texttt{\$a0}=\texttt{\$a0}/2$ 
    \item On appelle la fonction multiplier (récursivement, donc) pour calculer
    $(\texttt{\$a0} \times \texttt{\$a1})/2$, que l'on multiplie par 2 et que
    l'on stocke dans \texttt{\$v0}
    \item On fait $\texttt{\$v0}=\texttt{\$v0}+x$
    \item Et on renvoie \texttt{\$v0} !
  \end{enumerate}
}

\begin{frame}[fragile]
  \frametitle{Code MIPS obtenu}
  \tiny
  \begin{lstlisting}
  multiplier:
        bne     $a1, $zero, multiplier_debut 
        li      $a0, 0 # Si $a1 = 0, on met $a0 = 0
    multiplier_debut:
        move    $v0, $a0
        li      $t0, 1
        beq     $a1, $t0, multiplier_fin # Si $a1 = 1, on renvoie $a0
        addi    $sp, $sp, 4
        sw      $ra, 0($sp)
        addi    $sp, $sp, 4
        sw      $zero, 0($sp)
        andi    $t0, $a1, 1
        beq     $t0, $zero, multiplier_fintest
        sw      $a0, 0($sp) # On stocke x
    multiplier_fintest:
        srl     $a1, $a1, 1 # Division par 2
        jal     multiplier # On fait l'appel récursif
        add     $v0, $v0, $v0 # Multiplication par 2
        lw      $t0, 0($sp) # On ajoute x
        addi    $sp, $sp, -4
        add     $v0, $v0, $t0
        lw      $ra, 0($sp)
        addi    $sp, $sp, -4
    multiplier_fin:
        jr      $ra
  \end{lstlisting}
\end{frame}

\frame
{
  \frametitle{Principe de la division}
  Comme à l'école primaire ! Divisons \texttt{\$a0} par \texttt{\$a1} :
  \begin{enumerate}
    \item On initialise le quotient \texttt{\$v0} à 0
    \item Si a1 est plus grand que \texttt{\$a0}, on s'arrête là
    \item Sinon, on décale \texttt{\$a1} de $n$ bits le faire arriver juste
    en-dessous de \texttt{\$a0}
    \item On fait $\texttt{\$a0}=\texttt{\$a0}-(\texttt{\$a1}\times2^n)$, et on rajoute $2^n$ au quotient
    \item On revient à l'étape 2, et on recommence !
  \end{enumerate}
}

\begin{frame}[fragile]
  \frametitle{Code MIPS obtenu}
  \tiny
  \begin{lstlisting}
diviser:
        li      $v0, 0 # Initialisation
    diviser_debut:
        bgt     $a1, $a0, diviser_fin # Test de fin
        move    $t1, $a1
        li      $t2, 1
    diviser_petiteboucle:
        bgt     $t1, $a0, diviser_finpetiteboucle
        add     $t1, $t1, $t1 # On décale $t1 (=$a1 au départ)  
                              # jusqu'à dépasser $a0
        add     $t2, $t2, $t2 # On en profite pour calculer 2^n
        j       diviser_petiteboucle
    diviser_finpetiteboucle: 
        srl     $t1, $t1, 1 # On est allés un cran trop loin
        srl     $t2, $t2, 1
        sub     $a0, $a0, $t1 # On enlève ce qu'il faut à $a0
        add     $v0, $v0, $t2 # On rajoute ce qu'il faut à $v0
        j       diviser_debut # Et on retourne à l'étape 2
    diviser_fin:
        jr      $ra
  \end{lstlisting}
\end{frame}

\subsection{Calcul de la date et de l'heure}

\begin{frame}
  \frametitle{Calcul de l'heure}
  Le calcul de l'heure est la partie "simple" de l'algorithme de transformation
  du timestamp. En effet, le timestamp UNIX correspond au nombre de secondes
  écoulées depuis le $1^{er}$ janvier 1970. Comme il y a 86400 secondes dans une
  journée, il suffit donc de :
  \begin{itemize}
    \item Diviser le timestamp par 86400 secondes et prendre le reste : on
    obtient le nombre de secondes depuis le début de la journée.
    \item Diviser cette quantité par 3600 : on obtient le nombre d'heures
    écoulées depuis le début de la journée
    \item Prendre le reste de la division précédente, et le diviser par 60 : on
    obtient le nombre de minutes depuis le début de l'heure courante
    \item Et le reste de la précédente division donne directement les secondes
    écoulées depuis le début de la minute courante.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Calcul de la date - Années bissextiles}
  La première division par 86400 donne le nombre de jours écoulés depuis le
  01/01/1970. Pour calculer la date correspondante, on ne peut pas directement
  opérer par divisions comme précédemment : il faut d'abord prendre en compte le
  problème des années bissextiles.
  \vspace{0.5cm}
  Ma méthode est la suivante : on considère qu'une année "normale" dure $366$
  jours et on se contente de modifier en dur le nombre de jours écoulés, en
  ajoutant un jour artificiel à la fin de chaque $28$ février d'une année non
  bissextile. 
  \vspace{0.5cm}
  Ainsi, lorsqu'on est par exemple le 1er janvier 1970, on considère non pas que
  $31+28=59$ jours se sont écoulés mais $60$, pour compenser le fait que dans
  toute la suite, on considère que février a 29 jours.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Calcul de la date}
  Pour calculer le nombre d'années : on fait une division par 366 et on rajoute
  1970.\\
  \vspace{0.5cm}
  Pour calculer mois et jours : on fait du cas par cas pour chaque mois, faute
  de formule mathématique simple.
  \tiny
  \begin{lstlisting}
        addi    $t0, $t0, 29 # Février
        bgt     $t0, $s4, moistrouve
        addi    $s5, $s5, 1
        move    $t1, $t0
        addi    $t0, $t0, 31 # Mars
        bgt     $t0, $s4, moistrouve
        addi    $s5, $s5, 1
        move    $t1, $t0
        addi    $t0, $t0, 30 # Avril
        bgt     $t0, $s4, moistrouve
        addi    $s5, $s5, 1
        move    $t1, $t0
  \end{lstlisting}
\end{frame}

\subsection{Communication avec le reste du système}

\begin{frame}[fragile]
  \frametitle{Entrée / Sorties}
  Le programme prend un seul paramètre en entrée : le timestamp UNIX. Ce
  renseignement est disponible dans une adresse spéciale :
  \tiny
  \begin{lstlisting}
        li      $t0, timestamp
        lw      $s7, 0($t0)
  \end{lstlisting}
  \normalsize
  En sortie, il écrit dans une adresse spéciale du système le résultat de la
  transformation d'un entier en suite d'octets en format ``afficheur 7
  segments'' :
  \tiny
  \begin{lstlisting}
            add     $t0, $s2, $s2
            li      $t5, two_digits_to_segments 
            add     $t0, $t0, $t5
            lb      $t1, 0($t0)
            la      $t2, clock_display
            sb      $t1, 0($t2)
            add     $t0, $s2, $s2
            addi    $t0, $t0, 1
            li      $t5, two_digits_to_segments 
            add     $t0, $t0, $t5
            lb      $t1, 0($t0)
            sb      $t1, 1($t2)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conversion}
  Où \texttt{two\_digits\_to\_segments} est la table suivante :
  \tiny
  \begin{lstlisting}
two_digits_to_segments:
    .byte 0x3F, 0x3F, 0x3F, 0x06, 0x3F, 0x5B, 0x3F, 0x4F, 0x3F, 0x66, 0x3F,
    0x6D, 0x3F, 0x7D, 0x3F, 0x07, 0x3F, 0x7F, 0x3F, 0x6F, 0x06, 0x3F, 0x06,
    0x06, 0x06, 0x5B, 0x06, 0x4F, 0x06, 0x66, 0x06, 0x6D, 0x06, 0x7D, 0x06,
    0x07, 0x06, 0x7F, 0x06, 0x6F, 0x5B, 0x3F, 0x5B, 0x06, 0x5B, 0x5B, 0x5B,
    0x4F, 0x5B, 0x66, 0x5B, 0x6D, 0x5B, 0x7D, 0x5B, 0x07, 0x5B, 0x7F, 0x5B,
    0x6F, 0x4F, 0x3F, 0x4F, 0x06, 0x4F, 0x5B, 0x4F, 0x4F, 0x4F, 0x66, 0x4F,
    0x6D, 0x4F, 0x7D, 0x4F, 0x07, 0x4F, 0x7F, 0x4F, 0x6F, 0x66, 0x3F, 0x66,
    0x06, 0x66, 0x5B, 0x66, 0x4F, 0x66, 0x66, 0x66, 0x6D, 0x66, 0x7D, 0x66,
    0x07, 0x66, 0x7F, 0x66, 0x6F, 0x6D, 0x3F, 0x6D, 0x06, 0x6D, 0x5B, 0x6D,
    0x4F, 0x6D, 0x66, 0x6D, 0x6D, 0x6D, 0x7D, 0x6D, 0x07, 0x6D, 0x7F, 0x6D,
    0x6F, 0x7D, 0x3F, 0x7D, 0x06, 0x7D, 0x5B, 0x7D, 0x4F, 0x7D, 0x66, 0x7D,
    0x6D, 0x7D, 0x7D, 0x7D, 0x07, 0x7D, 0x7F, 0x7D, 0x6F, 0x07, 0x3F, 0x07,
    0x06, 0x07, 0x5B, 0x07, 0x4F, 0x07, 0x66, 0x07, 0x6D, 0x07, 0x7D, 0x07,
    0x07, 0x07, 0x7F, 0x07, 0x6F, 0x7F, 0x3F, 0x7F, 0x06, 0x7F, 0x5B, 0x7F,
    0x4F, 0x7F, 0x66, 0x7F, 0x6D, 0x7F, 0x7D, 0x7F, 0x07, 0x7F, 0x7F, 0x7F,
    0x6F, 0x6F, 0x3F, 0x6F, 0x06, 0x6F, 0x5B, 0x6F, 0x4F, 0x6F, 0x66, 0x6F,
    0x6D, 0x6F, 0x7D, 0x6F, 0x07, 0x6F, 0x7F, 0x6F, 0x6F 
  \end{lstlisting}
\end{frame}

\section{Fonctionnalité surprise}

\subsection{Aspect historique}

\begin{frame}
  \frametitle{!?!}

L'École normale dite « de l'an III », est créée à Paris par la Convention qui
décrète le 9 brumaire an III que : \\
  \vspace{0.5cm}
(article 1er) « Il sera établi à Paris une
École normale, où seront appelés, de toutes les parties de la République, des
citoyens déjà instruits dans les sciences utiles, pour apprendre, sous les
professeurs les plus habiles dans tous les genres, l'art d'enseigner. ». 

  \vspace{0.5cm}
    \tiny
    (Wikipédia)
\end{frame}

\begin{frame}
  \frametitle{Calendrier républicain}
  « 9 brumaire an III » ?\\
  \vspace{0.5cm}
  De 1792 à 1806 (période incluant donc la création de l'École Normale), en
  France, le calendrier grégorien n'a plus été utilisé, au profit du calendrier
  républicain, inventé par les révolutionnaires pour oublier l'empreinte
  religieuse présente dans le calendrier jusqu'à lors, depuis le nom des mois
  (Juin - Junon) jusqu'au nom des jours de la semaine (Mardi - jour de Vénus),
  sans oublier bien sûr les saints de chaque jour de l'année. 
\end{frame}

\begin{frame}
  \frametitle{Détails}
  Ainsi, les mois, dans l'ordre (en commançant par l'équivalent de septembre) :
  sont : Vendémiaire, Brumaire, Frimaire, Nivôse, Pluviôse, Ventôse, Germinal,
  Floréal, Prairial, Messidor, Thermidor, Fructidor.\\
  \vspace{0.5cm}
  Les jours de la "décade" : Primidi, Duodi, Tridi, Quartidi, Quinditi, Sextidi,
  Septidi, Octidi, Nonidi, Décadi.
\end{frame}

\subsection{Aspect pratique}

\begin{frame}
  \frametitle{Fonctionnement}
  Bonne nouvelle : Les années bissextiles sont synchronisées avec celles du
  calendrier grégorien !\\
  \vspace{0.5cm}
  Bonne nouvelle 2 : Tous les mois font 30 jours ! (on rajoute 5 ou 6 jours en
  fin d'année pour éviter le décalage avec l'année solaire)\\
  \vspace{0.5cm}
  Bonne nouvelle 3 : Le système d'heure est plus simple ! Il y a dix heures dans
  une journée, chacune coupée en cent ``minutes'', chacune coupée en cent
  ``secondes'', et ainsi de suite, jusqu'à ``la plus petite portion commensurable
  de la durée''\\
  \vspace{0.5cm}
  Quoique... Pour un timestamp en secondes, ça va peut-être pas être si pratique
  que ça...
\end{frame}

\subsection{Démonstration}

\begin{frame}
  \frametitle{Démo !}
  Sous vos yeux ébahis...
\end{frame}

\end{document}
